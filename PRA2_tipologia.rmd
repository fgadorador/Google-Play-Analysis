---
title: "Práctica 2: Limpieza y análisis de datos"
author: "Autores: Fernando García Dorador, Amanda Iglesias Moreno"
date: "17/12/2020"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Descripción del dataset. ¿Por qué es importante y qué pregunta/problema pretende responder?

bla bla bala

# Integración y selección de los datos de interés a analizar.
Primero, leeremos el csv donde se encuentran los datos:

```{r message= FALSE, warning=FALSE}
google_play <- read.csv("googleplaystore.csv")

```


# Preprocesamiento
Una vez leídos los datos, analizamos la estructura y tipología de los datos mediante la función *str*. Tambien importamos la librería *DataExplorer* que nos ayudará a realizar una análisis exploratorio visual posteriormente:
```{r message= FALSE, warning=FALSE}
library(DataExplorer) 
str(google_play)
```

Observamos que todas las variables menos *Rating* están en formato *chr*. De estas variables, algunas pueden convertirse a valor númerico como *Size*, *Reviews* y *Price*, y algunas otras se podrán discretizar si tienen pocos valores únicos.

A continuación realizamos un gráfico de barras de las variables con formato *chr* que tienen pocas categorías:
```{r message= FALSE, warning=FALSE}
plot_bar(google_play)
```

vemos que hay 2 de las variables (Installs y Type) tienen categorías que no deberían. Analizamos en concreto las filas donde esto ocurre:
```{r message= FALSE, warning=FALSE}
google_play[google_play$Installs == "Free",]

#eliminamos elemento 10473, ya que las columnas no están en orden y falta un campo
googleplay_clean <- google_play[-c(10473),]
```

Eliminamos la fila donde ocurría, puesto vemos que se ha movido y faltan campos. A continuación, analizamos el caso donde Installs es 0:

```{r message= FALSE, warning=FALSE}
str(googleplay_clean[googleplay_clean$Installs == "0",])

#se trata de un error y le añadimos el + al final para que tenga la misma estructura que los demás
googleplay_clean$Installs[googleplay_clean$Installs == '0'] <- "0+"
googleplay_clean$Type[googleplay_clean$Type == "NaN"] <- "Free"
```

Hemos comprobado que se trataba de un error de formato, además se ha sustitudo el valor de Type a "Free", puesto que el precio es 0.

## Preprocesamiento de Size
Ahora realizaremos el preprocesado de la variable size, que consistirá en transformar el tipo de datos a numérico. Para ello, primero eliminaremos las "M" y "k" de los valores, que indican megabytes y kilobytes respectivamente, y sustituiremos el valor "Varies with device" por NaN, para posteriormente extrapolar este valor utilizando kNN:

```{r message= FALSE, warning=FALSE}
mask1 <- grepl("[M]$", googleplay_clean$Size)
mask2 <- grepl("[k]$", googleplay_clean$Size)

googleplay_clean$Size <- lapply(googleplay_clean$Size, function(x) gsub("[M]$", "", x))
googleplay_clean$Size <- lapply(googleplay_clean$Size, function(x) gsub("[k]$", "", x))
googleplay_clean$Size <- lapply(googleplay_clean$Size, function(x) gsub("Varies with device", "NaN", x))

googleplay_clean$Size <- as.numeric(googleplay_clean$Size)
googleplay_clean$Size <- (1000*mask2*googleplay_clean$Size) + (1000000*mask1*googleplay_clean$Size)

str(googleplay_clean$Size)

```

## Preprocesamiento de Price

Hemos observado que la variable *Price* está en formato chr, nuestro objetivo es convertirla a valor numérico. Para conseguirlo, debemos eliminar el símbolo del $ que acompaña a los precios:
```{r message= FALSE, warning=FALSE}

googleplay_clean$Price <- lapply(googleplay_clean$Price, function(x) gsub("\\$", "", x))
googleplay_clean$Price <- as.numeric(googleplay_clean$Price)

str(googleplay_clean$Price)
```

## Preprocesamiento de Reviews

Esta variable también está en formato chr, por lo que cambiaremos el formato a numérico:
```{r message= FALSE, warning=FALSE}
googleplay_clean$Reviews <- as.numeric(googleplay_clean$Reviews)
```

## Análisis de valores perdidos
Ahora nos centraremos en el tratamiento de valores perdidos:
```{r message= FALSE, warning=FALSE}
colSums(is.na(googleplay_clean))
plot_missing(googleplay_clean)
```

Las variables *Size* y *Rating* tienen valores perdidos. Puesto que la eliminicaión del las filas donde hay valores nulos supondría la pérdida d un 15,64% de los datos que disponemos, no podemos considerarlo como una opción. En su lugar, imputaremos los datos perdidos utilizando la librería *mice*, concretamente el *predictive mean matching*:

```{r message= FALSE, warning=FALSE}
library(mice)

tmpData <- mice(googleplay_clean, m=5, maxit = 50, method = 'pmm', seed = 500)
summary(tmpData)

data_clean <- complete(tmpData,1)
```

Verificamos que no hay ningún valor perdido:
```{r message= FALSE, warning=FALSE}
colSums(is.na(data_clean))
```

## Discretización de variable categóricas

Antes de discretizar en catgorías las variables *chr*, primero analizamos el número de valores diferentes que tiene cada variable:
```{r message= FALSE, warning=FALSE}
# ¿Con qué variables tendría sentido un proceso de discretización?
apply(data_clean,2, function(x) length(unique(x)))
```

A partir de estos números, determinamos que será efectivo discretizar las variables *Category*, *Installs*, *Type*, *Content.rating* y *Android.Ver*:
```{r message= FALSE, warning=FALSE}
# Discretizamos las variables con pocas clases
cols<-c("Category","Installs","Type","Content.Rating", "Android.Ver")
for (i in cols){
  data_clean[,i] <- as.factor(data_clean[,i])
}

# Después de los cambios, analizamos la nueva estructura del conjunto de datos
str(data_clean)
```

## Análisis de outliers

```{r message= FALSE, warning=FALSE}
create_report(data_clean)
```