---
title: "Práctica 2: Limpieza y análisis de datos"
author: "Autores: Fernando García Dorador, Amanda Iglesias Moreno"
date: "17/12/2020"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Descripción del dataset. ¿Por qué es importante y qué pregunta/problema pretende responder?

bla bla bala

# Integración y selección de los datos de interés a analizar.
## Integración
Los datos con los que vamos a trabajar en esta prácica provienen de un único fichero "*googleplaystore.csv*", obtenido en la base de datos de kaggle: 

```{r message= FALSE, warning=FALSE}
google_play <- read.csv("googleplaystore.csv")

```
## Selección
En este proyecto nos interesa analizar toda la población de datos, por lo que no se realizará un filtrado de los datos.

Por otra parte, nos parece interesante analizar si el hecho de que una aplicación pertenezca a más de un género afecta a su rating. A continuación, creamos la variable *Multi_Genre*, que tomará valor 1 si tiene más de un género asociado o 0 en caso contrario:

```{r message= FALSE, warning=FALSE}
Multi_Genre <- lapply(google_play$Genres, function(x) ifelse(grepl(";", x, fixed = TRUE), "yes", "no"))

google_play$Multi_Genre <- as.character(Multi_Genre)

```

# Limpieza de los datos

Una vez leídos los datos, analizamos la estructura y tipología de los datos mediante la función *str*. También importamos la librería *DataExplorer* que nos ayudará a realizar un análisis exploratorio visual posteriormente:
```{r message= FALSE, warning=FALSE}
library(DataExplorer) 
str(google_play)
```

Observamos que todas las variables menos *Rating* están en formato *chr*. De estas variables, algunas pueden convertirse a valor númerico como *Size*, *Reviews* y *Price*, y algunas otras se podrán discretizar si tienen pocos valores únicos.

A continuación realizamos un gráfico de barras de las variables con formato *chr* que tienen pocas categorías:
```{r message= FALSE, warning=FALSE}
plot_bar(google_play)
```

vemos que hay 2 de las variables (Installs y Type) tienen categorías que no deberían. Analizamos en concreto las filas donde esto ocurre:
```{r message= FALSE, warning=FALSE}
google_play[google_play$Installs == "Free",]

#eliminamos elemento 10473, ya que las columnas no están en orden y falta un campo
googleplay_clean <- google_play[-c(10473),]
```

Eliminamos la fila donde ocurría, puesto vemos que se ha movido y faltan campos. A continuación, analizamos el caso donde Installs es 0:

```{r message= FALSE, warning=FALSE}
str(googleplay_clean[googleplay_clean$Installs == "0",])

#se trata de un error y le añadimos el + al final para que tenga la misma estructura que los demás
googleplay_clean$Installs[googleplay_clean$Installs == '0'] <- "0+"
googleplay_clean$Type[googleplay_clean$Type == "NaN"] <- "Free"
```

Hemos comprobado que se trataba de un error de formato, además se ha sustitudo el valor de Type a "Free", puesto que el precio es 0.

## Conversión de tipos de variables
### Conversión de Size

Ahora realizaremos el preprocesado de la variable size, que consistirá en transformar el tipo de datos a numérico. Para ello, primero eliminaremos las "M" y "k" de los valores, que indican megabytes y kilobytes respectivamente, y sustituiremos el valor "Varies with device" por NaN, para posteriormente extrapolar este valor utilizando kNN:

```{r message= FALSE, warning=FALSE}
mask1 <- grepl("[M]$", googleplay_clean$Size)
mask2 <- grepl("[k]$", googleplay_clean$Size)

googleplay_clean$Size <- lapply(googleplay_clean$Size, function(x) gsub("[M]$", "", x))
googleplay_clean$Size <- lapply(googleplay_clean$Size, function(x) gsub("[k]$", "", x))
googleplay_clean$Size <- lapply(googleplay_clean$Size, function(x) gsub("Varies with device", "NaN", x))

googleplay_clean$Size <- as.numeric(googleplay_clean$Size)
googleplay_clean$Size <- (1000*mask2*googleplay_clean$Size) + (1000000*mask1*googleplay_clean$Size)

str(googleplay_clean$Size)

```

### Conversión de Price

Hemos observado que la variable *Price* está en formato chr, nuestro objetivo es convertirla a valor numérico. Para conseguirlo, debemos eliminar el símbolo del $ que acompaña a los precios:
```{r message= FALSE, warning=FALSE}

googleplay_clean$Price <- lapply(googleplay_clean$Price, function(x) gsub("\\$", "", x))
googleplay_clean$Price <- as.numeric(googleplay_clean$Price)

str(googleplay_clean$Price)
```

### Conversión de Reviews

Esta variable también está en formato chr, por lo que cambiaremos el formato a numérico:
```{r message= FALSE, warning=FALSE}
googleplay_clean$Reviews <- as.numeric(googleplay_clean$Reviews)
```


### Conversión de Last.updated

```{r message= FALSE, warning=FALSE}
library(lubridate)
Time <- lapply(googleplay_clean$Last.Updated, function(x) parse_date_time(x,orders = "mdy"))

googleplay_clean$Last.Updated <- as.POSIXct(unlist(Time), origin = '1970-01-01')
googleplay_clean$Last.Updated <- as.character(ceiling_date(googleplay_clean$Last.Updated, "day"))
head(googleplay_clean)
```


## Análisis de valores perdidos
Ahora nos centraremos en el tratamiento de valores perdidos:
```{r message= FALSE, warning=FALSE}
colSums(is.na(googleplay_clean))
plot_missing(googleplay_clean)
```

Las variables *Size* y *Rating* tienen valores perdidos. Puesto que la eliminicaión del las filas donde hay valores nulos supondría la pérdida de un 15,64% de los datos que disponemos, no podemos considerarlo como una opción. En su lugar, imputaremos los datos perdidos utilizando la librería *mice*, concretamente el *predictive mean matching*:

```{r message= FALSE, warning=FALSE}
library(mice)

tmpData <- mice(googleplay_clean, m=5, maxit = 50, method = 'pmm', seed = 500)
summary(tmpData)

data_clean <- complete(tmpData,1)
```

Verificamos que no hay ningún valor perdido:
```{r message= FALSE, warning=FALSE}
colSums(is.na(data_clean))
```

## Discretización de variable categóricas

Antes de discretizar en catgorías las variables *chr*, primero analizamos el número de valores diferentes que tiene cada variable:
```{r message= FALSE, warning=FALSE}
# ¿Con qué variables tendría sentido un proceso de discretización?
apply(data_clean,2, function(x) length(unique(x)))
```

A partir de estos números, determinamos que será efectivo discretizar las variables *Category*, *Installs*, *Type*, *Content.rating*, *Android.Ver* y *Multi_Genre*:
```{r message= FALSE, warning=FALSE}
# Discretizamos las variables con pocas clases
cols<-c("Category","Installs","Type","Content.Rating", "Android.Ver", "Multi_Genre")
for (i in cols){
  data_clean[,i] <- as.factor(data_clean[,i])
}

# Después de los cambios, analizamos la nueva estructura del conjunto de datos
str(data_clean)
```

## Análisis de outliers

```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clean$Rating)$out
boxplot.stats(data_clean$Reviews)$out
boxplot.stats(data_clean$Price)$out
boxplot.stats(data_clean$Size)$out
```


# Análisis

## RandomForest

```{r message= FALSE, warning=FALSE}
library(randomForest)
library(caTools)
#use caTools function to split, SplitRatio for 70%:30% splitting
data1= sample.split(data_clean,SplitRatio = 0.3)

#subsetting into Train data
train =subset(data_clean,data1==TRUE)

#subsetting into Test data
test =subset(data_clean,data1==FALSE)

rf <- randomForest(Rating ~ Category + Reviews + Size + Installs + Type + Price + Content.Rating + Android.Ver + Multi_Genre, data = train)
pred <- predict(rf, newdata = test)
print(rf)
plot(data_clean$Rating - pred)
```

```{r message= FALSE, warning=FALSE}
linear <- lm(Rating ~ Category + Reviews + Size + Installs + Type + Price + Content.Rating + Android.Ver + Multi_Genre, data = data_clean)
summary(linear)
```


# Representacion de los resultados a partir de graficas y tablas
## Instalar la libreria para la visualizacion
```{r message= FALSE, warning=FALSE}
library(ggplot2)
library(gridExtra)
library(GGally)
library(dplyr)
```


## Distribucion de las puntuaciones
```{r message= FALSE, warning=FALSE}
ggplot(data_clean, aes(x=Rating))+
geom_histogram(binwidth= 0.2,color="darkblue", fill="blue", alpha=0.4)+
  xlab('rating (score between 0 and 5)')+
  ggtitle("Rating of the apps in Googleplay")+
  theme(plot.title = element_text(hjust = 0.5))
```

## Matriz de correlaciones
```{r message= FALSE, warning=FALSE}
ggpairs(data_clean[, c(4, 5, 8, 3)], title="correlogram with ggpairs()") 

```

## Matriz de correlaciones
```{r message= FALSE, warning=FALSE}
ggcorr(data_clean, method = c("everything", "pearson"))  

```

## Diagramas de cajas de las categorias 
```{r message= FALSE, warning=FALSE, fig.width = 10, fig.height=15}
ggplot(data_clean,aes(x=Rating,y=Category))+
  geom_boxplot() +
  geom_point(aes(fill='Mean'),stat='summary',
             fun.y=mean, shape = 23, size = 4) +
  scale_fill_manual('', values = c("Mean"='blue')) + 
  xlab("Rating") +
  ylab("Category") +
  ggtitle("Distribution of Ratings by Category")+
  theme(plot.title = element_text(hjust = 0.5),legend.position="right")
```

## Distribucion de las calificaciones por categoria
```{r message= FALSE, warning=FALSE, fig.width = 10, fig.height=60}
ggplot(data_clean, aes(x=Rating))+
geom_histogram(binwidth= 0.2,color="darkblue", fill="blue", alpha=0.4)+
  facet_grid(rows=vars(Category))
```

## Numero de apps por categoria
```{r message= FALSE, warning=FALSE, fig.width = 10, fig.height=10}
data_clean <- within(data_clean,
Category <- factor(Category,
levels=names(sort(table(Category),
decreasing=FALSE))))

ggplot(data_clean, aes(y=Category))+
geom_bar(color="darkblue", fill="blue", alpha=0.4)+
ggtitle("Number of apps per category")+
theme(plot.title = element_text(hjust = 0.5))
```















